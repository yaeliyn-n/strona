import discord
from discord.ext import commands
from discord.ext.commands import Context
import time
from datetime import datetime, UTC
import typing
import asyncio

import config # Import konfiguracji

if typing.TYPE_CHECKING:
    from bot import BotDiscord # Zak≈Çadamy, ≈ºe bot.py jest w g≈Ç√≥wnym katalogu


class Wlasciciel(commands.Cog, name="wlasciciel"):
    """üëë Kapsu≈Ça z komendami dostƒôpnymi tylko dla Tkacza Przeznacze≈Ñ (W≈Ça≈õciciela Bota)."""
    def __init__(self, bot: 'BotDiscord'):
        self.bot = bot

    async def _create_owner_embed(self, context: Context, title: str, description: str, color: discord.Color) -> discord.Embed:
        embed = discord.Embed(title=title, description=description, color=color, timestamp=datetime.now(UTC))
        if self.bot.user and self.bot.user.avatar:
            embed.set_author(name=f"Panel W≈Ça≈õciciela - {self.bot.user.display_name}", icon_url=self.bot.user.avatar.url)
        else:
            embed.set_author(name="Panel W≈Ça≈õciciela")

        if context.guild and context.guild.icon:
            embed.set_footer(text=f"Serwer: {context.guild.name} | Kroniki Elary", icon_url=context.guild.icon.url)
        else:
            embed.set_footer(text="Kroniki Elary")
        return embed

    @commands.command(
        name="synchronizuj",
        description="Synchronizuje komendy slash z Discordem. Opcjonalnie czy≈õci stare komendy.",
    )
    @commands.is_owner()
    async def synchronizuj(self, context: Context, scope: str = "global", action: str = "sync") -> None:
        """
        Standardowa synchronizacja komend slash.
        Zakres (scope): 'global' lub 'guild'. Domy≈õlnie 'global'.
        Akcja (action): 'sync' lub 'clear'. Domy≈õlnie 'sync'.
        """
        if scope.lower() not in ["global", "guild"]:
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈Çƒôdny Zakres Synchronizacji", "Mo≈ºliwe warto≈õci dla 'scope' to `global` lub `guild`.", config.KOLOR_ADMIN_BLAD_OWNER)
            await context.send(embed=embed, ephemeral=True); return

        if action.lower() not in ["sync", "clear"]:
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈Çƒôdna Akcja Synchronizacji", "Mo≈ºliwe warto≈õci dla 'action' to `sync` lub `clear`.", config.KOLOR_ADMIN_BLAD_OWNER)
            await context.send(embed=embed, ephemeral=True); return

        start_time = time.time()
        log_message_parts = []
        target_guild_obj = context.guild if scope.lower() == "guild" else None

        if action.lower() == "clear":
            self.bot.logger.info(f"Rozpoczynam czyszczenie komend dla zakresu: {scope} (serwer: {target_guild_obj.name if target_guild_obj else 'Globalnie'}).")
            try:
                if target_guild_obj:
                    self.bot.tree.clear_commands(guild=target_guild_obj)
                    await self.bot.tree.sync(guild=target_guild_obj)
                    log_message_parts.append(f"Wyczyszczono komendy aplikacji dla serwera **{target_guild_obj.name}**.")
                else:
                    self.bot.tree.clear_commands(guild=None)
                    await self.bot.tree.sync()
                    log_message_parts.append("Wyczyszczono **globalne** komendy aplikacji.")
                self.bot.logger.info(f"Zako≈Ñczono czyszczenie komend dla zakresu: {scope}.")
            except Exception as e:
                self.bot.logger.error(f"B≈ÇƒÖd podczas czyszczenia komend ({scope}): {e}", exc_info=True)
                log_message_parts.append(f"‚ùå B≈ÇƒÖd podczas czyszczenia komend ({scope}): `{e}`")

        # W≈Ça≈õciwa synchronizacja
        self.bot.logger.info(f"Rozpoczynam synchronizacjƒô komend dla zakresu: {scope} (serwer: {target_guild_obj.name if target_guild_obj else 'Globalnie'}).")
        try:
            synced_commands = []
            if target_guild_obj:
                # Je≈õli chcemy tylko synchronizowaƒá dla danego serwera, bez kopiowania globalnych:
                # synced_commands = await self.bot.tree.sync(guild=target_guild_obj)
                # Je≈õli chcemy skopiowaƒá globalne i zsynchronizowaƒá:
                self.bot.tree.copy_global_to(guild=target_guild_obj)
                synced_commands = await self.bot.tree.sync(guild=target_guild_obj)
            else:
                synced_commands = await self.bot.tree.sync()

            log_message_parts.append(f"Zsynchronizowano **{len(synced_commands)}** komend w zakresie **{scope}**.")
            self.bot.logger.info(f"Zako≈Ñczono synchronizacjƒô {len(synced_commands)} komend dla zakresu: {scope}.")
        except Exception as e:
            self.bot.logger.error(f"B≈ÇƒÖd podczas synchronizacji komend ({scope}): {e}", exc_info=True)
            log_message_parts.append(f"‚ùå B≈ÇƒÖd podczas synchronizacji komend ({scope}): `{e}`")

        end_time = time.time()
        czas_wykonania = end_time - start_time

        final_log_message = "\n".join(log_message_parts)
        embed_color = config.KOLOR_ADMIN_SUKCES_OWNER if "‚ùå" not in final_log_message else config.KOLOR_ADMIN_BLAD_OWNER
        embed = await self._create_owner_embed(context, "üîÑ Status Synchronizacji", f"{final_log_message}\nCzas wykonania: `{czas_wykonania:.2f}s`.", embed_color)
        await context.send(embed=embed)

    @commands.command(
        name="forcesync",
        description="Agresywnie czy≈õci i synchronizuje komendy slash dla serwera lub globalnie."
    )
    @commands.is_owner()
    async def forcesync(self, context: Context, scope: str = "guild"):
        """
        Agresywnie czy≈õci (ustawia pustƒÖ listƒô) i synchronizuje komendy.
        U≈ºywaj ostro≈ºnie, zw≈Çaszcza z 'global'.
        Zakres (scope): 'guild' (dla bie≈ºƒÖcego serwera) lub 'global'.
        """
        if scope.lower() not in ["guild", "global"]:
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈Çƒôdny Zakres", "Dozwolone zakresy: `guild` lub `global`.", config.KOLOR_ADMIN_BLAD_OWNER)
            await context.send(embed=embed); return

        target_guild_obj = context.guild if scope.lower() == "guild" else None
        if scope.lower() == "guild" and not target_guild_obj:
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈ÇƒÖd", "Zakres 'guild' wymaga wykonania komendy na serwerze.", config.KOLOR_ADMIN_BLAD_OWNER)
            await context.send(embed=embed); return

        start_time = time.time()
        messages = []
        color = config.KOLOR_ADMIN_BLAD_OWNER # Domy≈õlnie b≈ÇƒÖd

        try:
            self.bot.logger.info(f"[ForceSync] Czyszczenie komend dla zakresu '{scope}'...")
            if target_guild_obj:
                self.bot.tree.clear_commands(guild=target_guild_obj) 
                await self.bot.tree.sync(guild=target_guild_obj)     
                messages.append(f"Wyczyszczono komendy dla serwera **{target_guild_obj.name}**.")
                self.bot.logger.info(f"[ForceSync] Wys≈Çano pustƒÖ listƒô komend dla serwera {target_guild_obj.name}.")
            else: # global
                self.bot.tree.clear_commands(guild=None) 
                await self.bot.tree.sync(guild=None)    
                messages.append("Wyczyszczono **globalne** komendy aplikacji.")
                self.bot.logger.info("[ForceSync] Wys≈Çano pustƒÖ listƒô globalnych komend.")

            # Kr√≥tka pauza, aby Discord przetworzy≈Ç czyszczenie
            await asyncio.sleep(5) 

            self.bot.logger.info(f"[ForceSync] Rejestrowanie aktualnych komend dla zakresu '{scope}'...")
            synced_commands_count = 0
            if target_guild_obj:
                self.bot.tree.copy_global_to(guild=target_guild_obj) # Kopiuje globalne komendy do tego serwera
                synced = await self.bot.tree.sync(guild=target_guild_obj) # Synchronizuje (w tym skopiowane globalne i specyficzne dla serwera)
                synced_commands_count = len(synced)
            else: # global
                synced = await self.bot.tree.sync() # Synchronizuje globalne komendy
                synced_commands_count = len(synced)

            messages.append(f"Zarejestrowano **{synced_commands_count}** komend w zakresie **{scope}**.")
            self.bot.logger.info(f"[ForceSync] Zako≈Ñczono rejestracjƒô {synced_commands_count} komend dla zakresu: {scope}.")
            color = config.KOLOR_ADMIN_SUKCES_OWNER # Sukces, je≈õli dosz≈Ço tutaj bez b≈Çƒôdu

        except Exception as e:
            self.bot.logger.error(f"[ForceSync] B≈ÇƒÖd podczas force sync ({scope}): {e}", exc_info=True)
            messages.append(f"‚ùå B≈ÇƒÖd podczas force sync ({scope}): `{e}`")
            # Kolor pozostaje na b≈ÇƒÖd

        end_time = time.time()
        czas_wykonania = end_time - start_time
        final_message = "\n".join(messages)
        embed = await self._create_owner_embed(context, f"‚öôÔ∏è Force Sync Status ({scope.capitalize()})", f"{final_message}\nCzas wykonania: `{czas_wykonania:.2f}s`.", color)
        await context.send(embed=embed)


    @commands.command(
        name="rozladuj",
        aliases=["unload"],
        description="Roz≈Çadowuje wybranƒÖ kapsu≈Çƒô (cog).",
    )
    @commands.is_owner()
    async def rozladuj(self, context: Context, cog_name: str) -> None:
        try:
            await self.bot.unload_extension(f"cogs.{cog_name}")
            self.bot.logger.info(f"Pomy≈õlnie roz≈Çadowano kapsu≈Çƒô: {cog_name}")
            embed = await self._create_owner_embed(context, "üîß Kapsu≈Ça Roz≈Çadowana", f"Kapsu≈Ça `{cog_name}` zosta≈Ça pomy≈õlnie roz≈Çadowana.", config.KOLOR_ADMIN_SUKCES_OWNER)
        except commands.ExtensionNotLoaded:
            self.bot.logger.warning(f"Pr√≥ba roz≈Çadowania nieza≈Çadowanej kapsu≈Çy: {cog_name}")
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈ÇƒÖd Roz≈Çadowania", f"Kapsu≈Ça `{cog_name}` nie by≈Ça za≈Çadowana.", config.KOLOR_ADMIN_BLAD_OWNER)
        except Exception as e:
            self.bot.logger.error(f"B≈ÇƒÖd podczas roz≈Çadowywania kapsu≈Çy {cog_name}: {e}", exc_info=True)
            embed = await self._create_owner_embed(context, "‚ùå Krytyczny B≈ÇƒÖd Roz≈Çadowania", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas roz≈Çadowywania `{cog_name}`:\n```py\n{e}\n```", config.KOLOR_ADMIN_BLAD_OWNER)
        await context.send(embed=embed)

    @commands.command(
        name="zaladuj",
        aliases=["load"],
        description="≈Åaduje wybranƒÖ kapsu≈Çƒô (cog).",
    )
    @commands.is_owner()
    async def zaladuj(self, context: Context, cog_name: str) -> None:
        try:
            await self.bot.load_extension(f"cogs.{cog_name}")
            self.bot.logger.info(f"Pomy≈õlnie za≈Çadowano kapsu≈Çƒô: {cog_name}")
            embed = await self._create_owner_embed(context, "üîß Kapsu≈Ça Za≈Çadowana", f"Kapsu≈Ça `{cog_name}` zosta≈Ça pomy≈õlnie za≈Çadowana.", config.KOLOR_ADMIN_SUKCES_OWNER)
        except commands.ExtensionAlreadyLoaded:
            self.bot.logger.warning(f"Pr√≥ba za≈Çadowania ju≈º za≈Çadowanej kapsu≈Çy: {cog_name}")
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈ÇƒÖd ≈Åadowania", f"Kapsu≈Ça `{cog_name}` jest ju≈º za≈Çadowana.", config.KOLOR_ADMIN_BLAD_OWNER)
        except commands.ExtensionNotFound:
            self.bot.logger.error(f"Nie znaleziono kapsu≈Çy do za≈Çadowania: {cog_name}")
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈ÇƒÖd ≈Åadowania", f"Nie znaleziono kapsu≈Çy o nazwie `{cog_name}`.", config.KOLOR_ADMIN_BLAD_OWNER)
        except Exception as e:
            self.bot.logger.error(f"B≈ÇƒÖd podczas ≈Çadowania kapsu≈Çy {cog_name}: {e}", exc_info=True)
            embed = await self._create_owner_embed(context, "‚ùå Krytyczny B≈ÇƒÖd ≈Åadowania", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas ≈Çadowania `{cog_name}`:\n```py\n{e}\n```", config.KOLOR_ADMIN_BLAD_OWNER)
        await context.send(embed=embed)

    @commands.command(
        name="przeladuj",
        aliases=["reload"],
        description="Prze≈Çadowuje wybranƒÖ kapsu≈Çƒô (cog) lub wszystkie.",
    )
    @commands.is_owner()
    async def przeladuj(self, context: Context, cog_name: str) -> None:
        if cog_name.lower() in ["wszystkie", "all"]:
            reloaded_cogs = []
            errors = []
            for extension in list(self.bot.extensions.keys()): # list() aby uniknƒÖƒá b≈Çƒôdu zmiany rozmiaru podczas iteracji
                try:
                    await self.bot.reload_extension(extension)
                    reloaded_cogs.append(extension.split('.')[-1]) # Bierzemy tylko nazwƒô coga
                except Exception as e:
                    self.bot.logger.error(f"B≈ÇƒÖd podczas prze≈Çadowywania kapsu≈Çy {extension}: {e}", exc_info=True)
                    errors.append(f"**{extension.split('.')[-1]}**: {e}")

            if not errors:
                embed = await self._create_owner_embed(context, "üîß Wszystkie Kapsu≈Çy Prze≈Çadowane", f"Pomy≈õlnie prze≈Çadowano kapsu≈Çy: `{'`, `'.join(reloaded_cogs)}`.", config.KOLOR_ADMIN_SUKCES_OWNER)
            else:
                error_msg = "\n".join(errors)
                success_msg = f"Pomy≈õlnie prze≈Çadowano: `{'`, `'.join(reloaded_cogs)}`.\n\n" if reloaded_cogs else ""
                embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈Çƒôdy Podczas Prze≈Çadowywania", f"{success_msg}**B≈Çƒôdy:**\n{error_msg}", config.KOLOR_ADMIN_BLAD_OWNER)
            await context.send(embed=embed)
            return

        try:
            await self.bot.reload_extension(f"cogs.{cog_name}")
            self.bot.logger.info(f"Pomy≈õlnie prze≈Çadowano kapsu≈Çƒô: {cog_name}")
            embed = await self._create_owner_embed(context, "üîß Kapsu≈Ça Prze≈Çadowana", f"Kapsu≈Ça `{cog_name}` zosta≈Ça pomy≈õlnie prze≈Çadowana.", config.KOLOR_ADMIN_SUKCES_OWNER)
        except commands.ExtensionNotLoaded:
            self.bot.logger.warning(f"Pr√≥ba prze≈Çadowania nieza≈Çadowanej kapsu≈Çy: {cog_name}. ≈Åadowanie...")
            try:
                await self.bot.load_extension(f"cogs.{cog_name}")
                self.bot.logger.info(f"Pomy≈õlnie za≈Çadowano kapsu≈Çƒô: {cog_name} (po pr√≥bie prze≈Çadowania).")
                embed = await self._create_owner_embed(context, "üîß Kapsu≈Ça Za≈Çadowana", f"Kapsu≈Ça `{cog_name}` nie by≈Ça za≈Çadowana, wiƒôc zosta≈Ça za≈Çadowana.", config.KOLOR_ADMIN_SUKCES_OWNER)
            except Exception as e_load:
                self.bot.logger.error(f"B≈ÇƒÖd podczas ≈Çadowania kapsu≈Çy {cog_name} (po pr√≥bie prze≈Çadowania): {e_load}", exc_info=True)
                embed = await self._create_owner_embed(context, "‚ùå Krytyczny B≈ÇƒÖd", f"Kapsu≈Ça `{cog_name}` nie by≈Ça za≈Çadowana. Pr√≥ba za≈Çadowania r√≥wnie≈º nie powiod≈Ça siƒô:\n```py\n{e_load}\n```", config.KOLOR_ADMIN_BLAD_OWNER)
        except Exception as e:
            self.bot.logger.error(f"B≈ÇƒÖd podczas prze≈Çadowywania kapsu≈Çy {cog_name}: {e}", exc_info=True)
            embed = await self._create_owner_embed(context, "‚ùå Krytyczny B≈ÇƒÖd Prze≈Çadowania", f"WystƒÖpi≈Ç b≈ÇƒÖd podczas prze≈Çadowywania `{cog_name}`:\n```py\n{e}\n```", config.KOLOR_ADMIN_BLAD_OWNER)
        await context.send(embed=embed)

    @commands.command(
        name="restart", description="Restartuje bota (je≈õli skonfigurowano z procesem nadrzƒôdnym)."
    )
    @commands.is_owner()
    async def restart(self, context: Context) -> None:
        embed = await self._create_owner_embed(context, "üîÑ Restartowanie Kronik Elary...", "Otrzymano polecenie restartu. Za chwilƒô powinienem powr√≥ciƒá do ≈ºycia.", config.KOLOR_ADMIN_SPECIAL_OWNER)
        await context.send(embed=embed)
        self.bot.logger.info("Otrzymano polecenie restartu. Pr√≥ba zamkniƒôcia po≈ÇƒÖczenia...")
        # W praktyce, proces nadrzƒôdny (np. systemd, skrypt shell) powinien monitorowaƒá bota i go zrestartowaƒá.
        # Samo bot.close() tylko zako≈Ñczy dzia≈Çanie obecnej instancji.
        await self.bot.close() 

    @commands.command(
        name="wylacz",
        aliases=["shutdown"],
        description="Wy≈ÇƒÖcza bota.",
    )
    @commands.is_owner()
    async def wylacz(self, context: Context) -> None:
        embed = await self._create_owner_embed(context, "üîå Wy≈ÇƒÖczanie Kronik Elary...", "Do zobaczenia wkr√≥tce, Kronikarze! Zapisujƒô ostatnie zwoje...", config.KOLOR_ADMIN_SPECIAL_OWNER)
        await context.send(embed=embed)
        self.bot.logger.info("Otrzymano polecenie wy≈ÇƒÖczenia. Zamykanie...")
        await self.bot.close()

    @commands.command(
        name="prefix",
        description="Zmienia prefix bota (tylko dla komend tekstowych)."
    )
    @commands.is_owner()
    async def prefix(self, context: Context, nowy_prefix: str) -> None:
        if len(nowy_prefix) > 5:
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è B≈Çƒôdny Prefix", "Prefix nie mo≈ºe byƒá d≈Çu≈ºszy ni≈º 5 znak√≥w.", config.KOLOR_ADMIN_BLAD_OWNER)
            await context.send(embed=embed); return

        # Zmiana prefixu w `commands.Bot` wymaga ponownego przypisania `command_prefix`
        # Je≈õli `command_prefix` by≈Ço funkcjƒÖ (np. `commands.when_mentioned_or(...)`),
        # to trzeba by jƒÖ zrekonstruowaƒá. W tym przypadku zak≈Çadamy, ≈ºe jest to prosty string
        # lub lista string√≥w.
        # Dla `commands.when_mentioned_or` mo≈ºna by przechowywaƒá oryginalne prefixy i je modyfikowaƒá.
        # Tutaj upraszczamy, zak≈ÇadajƒÖc, ≈ºe `self.bot.prefix_bota` jest g≈Ç√≥wnym prefixem.
        
        self.bot.prefix_bota = nowy_prefix # Aktualizacja atrybutu w klasie bota
        self.bot.command_prefix = commands.when_mentioned_or(nowy_prefix) # Aktualizacja atrybutu w instancji bota

        self.bot.logger.info(f"Zmieniono prefix bota na: '{nowy_prefix}'")
        embed = await self._create_owner_embed(context, "‚öôÔ∏è Prefix Zmieniony", f"Nowy prefix dla komend tekstowych to: `{nowy_prefix}`\nTeraz bot bƒôdzie reagowa≈Ç na `{nowy_prefix}nazwa_komendy` oraz na wzmiankƒô.", config.KOLOR_ADMIN_SUKCES_OWNER)
        await context.send(embed=embed)

    @commands.command(
        name="ustawstatus",
        description="Ustawia niestandardowy status bota."
    )
    @commands.is_owner()
    async def ustawstatus(self, context: Context, *, tekst_statusu: str):
        if len(tekst_statusu) > 128:
            embed = await self._create_owner_embed(context, "‚ö†Ô∏è Tekst Statusu Za D≈Çugi", "Status mo≈ºe mieƒá maksymalnie 128 znak√≥w.", config.KOLOR_ADMIN_BLAD_OWNER)
            await context.send(embed=embed); return

        if hasattr(self.bot, 'zadanie_statusu') and self.bot.zadanie_statusu.is_running(): # type: ignore
            self.bot.zadanie_statusu.cancel() # type: ignore
            self.bot.logger.info("Zatrzymano automatycznƒÖ pƒôtlƒô status√≥w, aby ustawiƒá status niestandardowy.")

        try:
            await self.bot.change_presence(activity=discord.Game(name=tekst_statusu))
            self.bot.logger.info(f"Ustawiono niestandardowy status: '{tekst_statusu}'")
            embed = await self._create_owner_embed(context, "‚ú® Status Ustawiony", f"Nowy status bota to: **{tekst_statusu}**\n_Aby przywr√≥ciƒá losowe statusy, u≈ºyj komendy `przeladuj status` (je≈õli taka istnieje) lub zrestartuj bota._", config.KOLOR_ADMIN_SUKCES_OWNER)
        except Exception as e:
            self.bot.logger.error(f"B≈ÇƒÖd podczas ustawiania statusu: {e}", exc_info=True)
            embed = await self._create_owner_embed(context, "‚ùå B≈ÇƒÖd Ustawiania Statusu", f"Nie uda≈Ço siƒô ustawiƒá statusu:\n```py\n{e}\n```", config.KOLOR_ADMIN_BLAD_OWNER)
        await context.send(embed=embed)

async def setup(bot: 'BotDiscord'):
    await bot.add_cog(Wlasciciel(bot))
